<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>基础知识 笔记 | luckyLL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="类型判断 | == 与 === | 作用域与作用域链 | 值传递和引用传递 | 内存回收 GC 与内存泄漏 | const &amp;amp; Object.freeze | 原型继承 与 类式继承 | nodeJs 热更新实现 | DOM的级别 | 标准盒模型&amp;amp;怪异盒模型 | flexbox 与 grid | 清除浮动 | CommonJS/AMD/CMD/UMD/ES6 | HTTP 缓存机制">
<meta property="og:type" content="article">
<meta property="og:title" content="基础知识 笔记">
<meta property="og:url" content="http://yoursite.com/2016/12/23/基础知识/index.html">
<meta property="og:site_name" content="luckyLL">
<meta property="og:description" content="类型判断 | == 与 === | 作用域与作用域链 | 值传递和引用传递 | 内存回收 GC 与内存泄漏 | const &amp;amp; Object.freeze | 原型继承 与 类式继承 | nodeJs 热更新实现 | DOM的级别 | 标准盒模型&amp;amp;怪异盒模型 | flexbox 与 grid | 清除浮动 | CommonJS/AMD/CMD/UMD/ES6 | HTTP 缓存机制">
<meta property="og:updated_time" content="2018-03-02T08:08:34.308Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基础知识 笔记">
<meta name="twitter:description" content="类型判断 | == 与 === | 作用域与作用域链 | 值传递和引用传递 | 内存回收 GC 与内存泄漏 | const &amp;amp; Object.freeze | 原型继承 与 类式继承 | nodeJs 热更新实现 | DOM的级别 | 标准盒模型&amp;amp;怪异盒模型 | flexbox 与 grid | 清除浮动 | CommonJS/AMD/CMD/UMD/ES6 | HTTP 缓存机制">
  
    <link rel="alternate" href="/atom.xml" title="luckyLL" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">luckyLL</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/23/基础知识/" class="article-date">
  <time datetime="2016-12-23T09:18:09.462Z" itemprop="datePublished">2016-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      基础知识 笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="#1">类型判断</a> | <a href="#2">== 与 ===</a> | <a href="#3">作用域与作用域链</a> | <a href="#4">值传递和引用传递</a> | <a href="#5">内存回收 GC 与内存泄漏</a> | <a href="#6">const &amp; Object.freeze</a> | <a href="#7">原型继承 与 类式继承</a> | <a href="#8">nodeJs 热更新实现</a> | <a href="#9">DOM的级别</a> | <a href="#10">标准盒模型&amp;怪异盒模型</a> | <a href="#11">flexbox 与 grid</a> | <a href="#12">清除浮动</a> | <a href="#13">CommonJS/AMD/CMD/UMD/ES6</a> | <a href="#13">HTTP 缓存机制</a></p>
<h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a><h3 id="1">类型判断</h3></h3><ul>
<li><strong><code>typeof</code></strong> 结果只会有五种类型 <code>Number / String / Object / Undefined / Function</code></li>
<li><strong><code>instanceof</code></strong> 判断是否出现在原型链上</li>
<li><strong><code>Object.prototype.toString.call</code></strong> 返回详细的类型 <code>[object Number]</code></li>
</ul>
<h3 id="与"><a href="#与" class="headerlink" title="== 与 ==="></a><h3 id="2">== 与 ===</h3></h3><ul>
<li><strong><code>==</code></strong>  判断两个值是否相等<ol>
<li>判断 typeof 结果值是否一致，如果不一致转2，否则转3</li>
<li>将不一致的转化成一致，优先转化成 number,转3</li>
<li>类型为引入类型，则判断引用的地址是否相等，否则直接判断值</li>
</ol>
</li>
<li><strong><code>===</code></strong>  与 == 区别在于，对typeof判断结果值也严格要求一致<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NaN != any</div><div class="line">undefined == null // if x is null and y is undefined, return true</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="作用域与作用域链-Scope-Scope-Chain"><a href="#作用域与作用域链-Scope-Scope-Chain" class="headerlink" title="作用域与作用域链(Scope/Scope Chain)"></a><h3 id="3">作用域与作用域链(Scope/Scope Chain)</h3></h3><ol>
<li>javaScript 解析器在一开始执行时,会把变量的声明部分提到函数的顶部执行(预解析).</li>
<li>全局变量的定义，会一层层的往外查找。如果找到则给该变量赋值，否则定义在 window 上</li>
<li>函数执行时会根据变量的作用域链,先查找本函数内的局部变量,然后一层层往外查找,直到找到最外层<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function outer () &#123;</div><div class="line">  var i = 10;</div><div class="line">  ?????????</div><div class="line">  function inner () &#123;</div><div class="line">    j = 100;</div><div class="line">    var k = 1000;</div><div class="line">    console.log(i + j +k); // 输出1110</div><div class="line">  &#125;</div><div class="line">  inner();</div><div class="line">  console.log(k); // error：&apos;k not define&apos;</div><div class="line">&#125;</div><div class="line">outer();</div><div class="line">console.log(j); // 100</div><div class="line"></div><div class="line">如果??????加上 var j = 200 会输出什么</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a><h3 id="4">值传递和引用传递</h3></h3><p>JS 传参时。原始数据类型都是值传递，<br>引用数据类型则是引用传递（Object，Function，Array，Date）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">var b = &#123;key: &apos;old&apos;&#125;;</div><div class="line">var c= &#123;key: &apos;old&apos;&#125;;</div><div class="line">function test(a, b, c) &#123;</div><div class="line">  a = 2;</div><div class="line">  b = &#123;key: &apos;new&apos;&#125;;</div><div class="line">  c.key = &apos;new&apos;;</div><div class="line">&#125;</div><div class="line">test(a, b, c)</div><div class="line">console.log(a) // 1 值传递</div><div class="line">console.log(b.key) // old 引用传递，但是并没有改变引用值，而是改变引用地址</div><div class="line">console.log(c.key) // new 引用传递，改变了引用地址的值</div></pre></td></tr></table></figure></p>
<h3 id="内存回收-GC-与内存泄漏"><a href="#内存回收-GC-与内存泄漏" class="headerlink" title="内存回收 GC 与内存泄漏"></a><h3 id="5">内存回收 GC 与内存泄漏</h3></h3><p>基础数据类型存在栈内存（读取速度快），引用数据类型存在堆内存（内存大）。<br>GC 会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p>
<ul>
<li>标记清除：变量进入某个环境时，标记为进入环境，离开环境时同样标记，继而清除其占用的内存</li>
<li>引用计数：记录该块内存被引用的次数，当次数为 0 时，清除</li>
</ul>
<h3 id="const-amp-Object-freeze"><a href="#const-amp-Object-freeze" class="headerlink" title="const &amp; Object.freeze"></a><h3 id="6">const &amp; Object.freeze</h3></h3><ul>
<li>const 声明引用类型时，只是规定该指针不可变</li>
<li>Object.freeze 冻结对象，完全不可变</li>
</ul>
<h3 id="原型继承-与-类式继承"><a href="#原型继承-与-类式继承" class="headerlink" title="原型继承 与 类式继承"></a><h3 id="7">原型继承 与 类式继承</h3></h3><ul>
<li><p>原型继承：将被继承的对象放到该对象的原型链上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var A = function()&#123;</div><div class="line">    this.x = &apos;ax&apos;</div><div class="line">&#125;</div><div class="line">var B = function()&#123;&#125;</div><div class="line">// 适用于B已经定义完成的继承</div><div class="line">B.prototype = new A()</div><div class="line">var b = new B()</div><div class="line">alert(b.x) // ax</div></pre></td></tr></table></figure>
</li>
<li><p>类式继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var A = function()&#123;</div><div class="line">    this.x = &apos;ax&apos;</div><div class="line">&#125;</div><div class="line">var B = function()&#123;</div><div class="line">    A.call(this)</div><div class="line">&#125;</div><div class="line">var b = new B()</div><div class="line">alert(b.x) // ax</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="nodeJs-热更新实现"><a href="#nodeJs-热更新实现" class="headerlink" title="nodeJs 热更新实现"></a><h3 id="8">nodeJs 热更新实现</h3></h3><blockquote>
<p>module._load 默认去找 module._cache,因此删除 require.cache(xx) 即可实现</p>
</blockquote>
<h3 id="DOM的级别"><a href="#DOM的级别" class="headerlink" title="DOM的级别"></a><h3 id="9">DOM的级别</h3></h3><ul>
<li>DOM1级 主要规定了如何映射XML文档结构以及扩展了 HTML 的对象和方法</li>
<li>DOM2级 增加了下列新模块 DOM视图/事件(addEventListener)/样式/遍历</li>
<li>DOM3级 扩展了DOM的加载和保存/验证等</li>
</ul>
<p>所谓DOM0级只是代表DOM未形成标准前的一个参照点</p>
<h5 id="DOM0级与DOM2级事件"><a href="#DOM0级与DOM2级事件" class="headerlink" title="DOM0级与DOM2级事件"></a>DOM0级与DOM2级事件</h5><p>绑定事件： <code>&lt;.. onclick /&gt;    xxx.onclick=...    xxx.addEventListener...</code></p>
<ul>
<li>0级事件：使用DOM的默认事件机制，监听属性，事件会互相覆盖</li>
<li>2级事件：增加了处理事件的方法(addEventListener)，事件不会覆盖</li>
</ul>
<h3 id="标准盒模型-amp-怪异盒模型"><a href="#标准盒模型-amp-怪异盒模型" class="headerlink" title="标准盒模型&amp;怪异盒模型"></a><h3 id="10">标准盒模型&amp;怪异盒模型</h3></h3><ul>
<li>标准盒模型： width = content</li>
<li>怪异盒模型： width = padding + border + content 当总宽度固定时可采用</li>
</ul>
<p>通过 box-sizing 切换 border-box/content-box</p>
<h3 id="flexbox-与-grid"><a href="#flexbox-与-grid" class="headerlink" title="flexbox 与 grid"></a><h3 id="11">flexbox 与 grid</h3></h3><ul>
<li>flexbox提供一个灵活可自动调整的布局方式</li>
</ul>
<p>flexbox需要在外层容器设置display:flex，内层的Item才能生效</p>
<h5 id="Flex-属性说明"><a href="#Flex-属性说明" class="headerlink" title="Flex 属性说明"></a>Flex 属性说明</h5><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>flex-direction</td>
<td>item 的排列方向</td>
<td>row/row-reverse/column…</td>
</tr>
<tr>
<td>flex-wrap</td>
<td>item 的换行策略</td>
<td>wrap/nowrap</td>
</tr>
<tr>
<td>flex-flow</td>
<td>flex-direction与flex-wrap的合并简写</td>
</tr>
<tr>
<td>justify-content</td>
<td>主轴的方向</td>
<td>flex-start/flex-end/center/space-between/space-around</td>
</tr>
<tr>
<td>align-items</td>
<td>交叉轴的对齐方向</td>
<td>flex-start/flex-end/center/stretch</td>
</tr>
<tr>
<td>aligin-content</td>
<td>多根轴线的对齐方式</td>
</tr>
</tbody>
</table>
<h5 id="Item-属性说明"><a href="#Item-属性说明" class="headerlink" title="Item 属性说明"></a>Item 属性说明</h5><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>order</td>
<td>item排序,从小到大</td>
<td>int</td>
</tr>
<tr>
<td>flex</td>
<td>缩小放大未来大小属性集合，一般只写flex-grow</td>
<td>int</td>
</tr>
<tr>
<td>align-self</td>
<td>对齐方式,会覆盖align-items</td>
<td>同align-items</td>
</tr>
</tbody>
</table>
<ul>
<li>grid是一个基于二维网格布局的系统</li>
</ul>
<p>grid布局需要外层容器定义display:grid</p>
<h5 id="Grid-属性说明"><a href="#Grid-属性说明" class="headerlink" title="Grid 属性说明"></a>Grid 属性说明</h5><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>grid-template-columns/rows</td>
<td>各列/行的大小</td>
<td>length length …</td>
</tr>
<tr>
<td>grid-gap(grid-column/row-gap)</td>
<td>各列/行的间距</td>
<td>length</td>
</tr>
<tr>
<td>justify-items/align-items</td>
<td>沿列轴/行轴对齐方式</td>
<td>start/end/center/stretch</td>
</tr>
<tr>
<td>justify-content/align-content</td>
<td>外层容器的对齐方式</td>
<td>…</td>
</tr>
<tr>
<td>grid-auto-columns/rows</td>
<td>grid之外的隐式网格大小</td>
</tr>
<tr>
<td>grid-auto-flow</td>
<td>自动排列的方向</td>
<td>row(dense)/column(dense)</td>
</tr>
</tbody>
</table>
<h5 id="Item-属性说明-1"><a href="#Item-属性说明-1" class="headerlink" title="Item 属性说明"></a>Item 属性说明</h5><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>grid-column/row-start/end</td>
<td>item的覆盖行列起止</td>
<td>int</td>
</tr>
<tr>
<td>grid-column/row</td>
<td>item的行列位置</td>
<td>int</td>
</tr>
</tbody>
</table>
<p>justify-self/align-self|行列的对齐方式，覆盖父级|</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a><h3 id="12">清除浮动</h3></h3><p>问题：浮动的存在会导致父元素的高度崩塌</p>
<p>清除浮动的方法（ps: clear只作用于被定义的元素本身，BFC 块级排版上下文）</p>
<ol>
<li>父元素加 overflow:hidden/auto             =&gt;  会被隐藏或者出来滚动条</li>
</ol>
<p><strong>原理：设置 overflow:hidden，该元素与子元素都会在同个独立的块级上下文上</strong></p>
<ol>
<li>父元素加伪类 :after 和 zoom（兼容IE6/7）clear: both  =&gt;  推荐使用</li>
<li>结尾加空标签并加上 clear: both            =&gt;  增加DOM结构</li>
</ol>
<p><strong>原理：空标签/伪类加上clear: both，会出现在浮动元素的下方，外层容器也就被撑开</strong></p>
<h3 id="CommonJS-AMD-CMD-UMD-ES6"><a href="#CommonJS-AMD-CMD-UMD-ES6" class="headerlink" title="CommonJS/AMD/CMD/UMD/ES6"></a><h3 id="13">CommonJS/AMD/CMD/UMD/ES6</h3></h3><ul>
<li><p>CommonJS：适用于服务端的规范。CommonJS 规定一个文件就是一个模块，当执行 require 时会执行对应文件的内容，由于文件存储在硬盘，因此读取速度比较快。比较适用于同步的执行方式，所以不适合浏览器环境。</p>
<p><strong><code>require()</code> 用来引入外部模块</strong><br><strong><code>exports</code> 对象用于导出当前模块的方法或变量，唯一的导出口</strong><br><strong><code>module</code> 对象就代表模块本身。</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var clock = require(&apos;clock&apos;)</div></pre></td></tr></table></figure>
<ul>
<li><p>AMD：异步加载模块，适用于define方法定义模块，前置依赖（requirejs）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// define(id?, dependencies?, factory)</div><div class="line">define([&apos;module1&apos;, &apos;module2&apos;], function(module1, module2) &#123;</div><div class="line">    // do something</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>CMD：与AMD类似，就近依赖（seajs）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define(function(require, exports, module) &#123;</div><div class="line">    var a = require(&apos;a&apos;)</div><div class="line">    a.test()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>UMD：CMD 与 AMD 的结合，UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 Node.js 模块模式。<br>在判断是否支持 AMD（define是否存在），存在则使用 AMD 方式加载模块</p>
</li>
<li><p>ES6： 上述方法载入模块都为运行时加载，而ES6为编译时加载，不会载入不用的代码</p>
</li>
</ul>
<h3 id="HTTP-缓存机制"><a href="#HTTP-缓存机制" class="headerlink" title="HTTP 缓存机制"></a><h3 id="14">HTTP 缓存机制</h3></h3><blockquote>
<p>HTTP 缓存分成强制缓存和协商缓存两种,通过HTTP的Header来控制缓存行为</p>
<ul>
<li>强制缓存：发起请求， 当命中该缓存且不失效，直接返回该结果。当浏览器未命中该缓存，则去服务端获取该资源，返回结果，并且加到缓存中。<br>强制缓存通过 Header 中的 Expires 和 Cache-Control 来控制</li>
</ul>
</blockquote>
<pre><code>- Expires的值为服务端返回的资源的过期时间，改字段为 Http1.0 的内容，服务端时间与客户端可能存在误差，因此逐渐被Cache-Control替代
- Cache-Control的取值有`private、public、no-cache、no-store、max-age`

    - private：客户端可以缓存
    - public：客户端和服务端都可以缓存
    - no-store：客户端和服务端都不缓存
    - max-age=XXX：与Expires类似，单位是秒，代表XXX秒后失效
    - ==no-cache：采用协商缓存==
</code></pre><ul>
<li><p>协商缓存：发起请求，当命中该缓存，获得该缓存的标识符，去服务端验证是否有效，有效则直接使用该缓存，否则请求服务端。未命中也一样请求服务端。<br>协商缓存通过 Last-Modified / If-Modified-Since 或者 Etag / If-None-Match（优先级高）</p>
<ul>
<li><p>Last-Modified / If-Modified-Since：Response Header 返回 Last-Modified 表示该资源最近修改的时间，Request Header上的 If-Modified-Since 表示本地缓存的该资源的时间，如果 Last-Modified &lt; If-Modified-Since的话,则使用本地的缓存</p>
</li>
<li><p>Etag / If-None-Match：Etag表示最近修改资源的标识符，If-None-Match表示最近一次获取到的资源的标识符，判断两者相等的话就使用本地缓存</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/23/基础知识/" data-id="cje9nu0b50000n8pmiscnp562" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/06/19/排序算法/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          排序算法
        
      </div>
    </a>
  
  
    <a href="/2016/12/08/JS 笔记/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JavaScript 笔记</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/19/排序算法/">排序算法</a>
          </li>
        
          <li>
            <a href="/2016/12/23/基础知识/">基础知识 笔记</a>
          </li>
        
          <li>
            <a href="/2016/12/08/JS 笔记/">JavaScript 笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 YR lei<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>